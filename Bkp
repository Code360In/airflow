import os

from tidb_vector.integrations import TiDBVectorClient
from sentence_transformers import SentenceTransformer
from dotenv import load_dotenv

embed_model = SentenceTransformer("sentence-transformers/all-MiniLM-L12-v2")
embed_model_dims = embed_model.get_sentence_embedding_dimension()

def text_to_embedding(text):
    """Generates vector embeddings for the given text."""
    embedding = embed_model.encode(text)
    return embedding.tolist()

vector_store = TiDBVectorClient(
    # The table which will store the vector data.
    table_name='embedded_sentense',
    # The connection string to the TiDB cluster.
    # The connection string should be in the format of:
    # mysql+pymysql://<USER>:<PASSWORD>@<HOST>:4000/<DATABASE>?ssl_ca=<CA_PATH>&ssl_verify_cert=true&ssl_verify_identity=true
    #connection_string=os.environ.get('TIDB_DATABASE_URL'),
    # The dimension of the vector generated by the embedding model.
    connection_string="mysql+pymysql://3L2PZikuPiTpAnP.root:VcbXhTENSUHdXw9W@gateway01.ap-southeast-1.prod.aws.tidbcloud.com:4000/test?ssl_ca=C:\\Users\\subrata.parida\\Downloads&ssl_verify_cert=true&ssl_verify_identity=true",
    vector_dimension=embed_model_dims,
    # Determine whether to recreate the table if it already exists.
    drop_existing_table=True,
)

documents = [
    {
        "id": "f8e7dee2-63b6-42f1-8b60-2d46710c1971",
        "text": "dog",
        "embedding": text_to_embedding("This is a dog"),
        "metadata": {"category": "animal"},
    },
    {
        "id": "8dde1fbc-2522-4ca2-aedf-5dcb2966d1c6",
        "text": "fish",
        "embedding": text_to_embedding("Fish lives in water and swimming"),
        "metadata": {"category": "animal"},
    },
    {
        "id": "e4991349-d00b-485c-a481-f61695f2b5ae",
        "text": "tree",
        "embedding": text_to_embedding("This is a plant tree"),
        "metadata": {"category": "plant"},
    },
]

vector_store.insert(
    ids=[doc["id"] for doc in documents],
    texts=[doc["text"] for doc in documents],
    embeddings=[doc["embedding"] for doc in documents],
    metadatas=[doc["metadata"] for doc in documents],
)

def print_result(query, result):
    print(f"Search result (\"{query}\"):")
    for r in result:
        print(f"- text: \"{r.document}\", distance: {r.distance}")
        
query = "a swimming animal"
query_embedding = text_to_embedding(query)
search_result = vector_store.query(query_embedding, k=3)
print_result(query, search_result)

vector_store = TiDBVectorClient(
    # The table which will store the vector data.
    table_name='embedded_sentense',
    # The connection string to the TiDB cluster.
    # The connection string should be in the format of:
    # mysql+pymysql://<USER>:<PASSWORD>@<HOST>:4000/<DATABASE>?ssl_ca=<CA_PATH>&ssl_verify_cert=true&ssl_verify_identity=true
    #connection_string=os.environ.get('TIDB_DATABASE_URL'),
    # The dimension of the vector generated by the embedding model.
    connection_string="mysql+pymysql://3L2PZikuPiTpAnP.root:VcbXhTENSUHdXw9W@gateway01.ap-southeast-1.prod.aws.tidbcloud.com:4000/test?ssl_ca=C:\\Users\\subrata.parida\\Downloads&ssl_verify_cert=true&ssl_verify_identity=true",
    vector_dimension=embed_model_dims,
    # Determine whether to recreate the table if it already exists.
    drop_existing_table=False,
)

documents = [
    {
        "id": "f8e7dee2-63b6-42f1-8b60-2d46710c1981",
        "text": "dog",
        "embedding": text_to_embedding("is not recognized as an internal or external command,operable program or batch file, this is to get the correct good food fron the sentence which is very Today, we're excited to announce that we are making things even simpler. We are providing a downloadable Hugging Face all-Mini.DBMS_DATA_MINING.IMPORT_ONNX_MODEL. The model available for download represents an augmented pipeline that includes tokenization"),
        "metadata": {"category": "none"},
    }
]

vector_store.insert(
    ids=[doc["id"] for doc in documents],
    texts=[doc["text"] for doc in documents],
    embeddings=[doc["embedding"] for doc in documents],
    metadatas=[doc["metadata"] for doc in documents],
)


